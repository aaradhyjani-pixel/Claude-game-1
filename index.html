<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Flappy You ‚Äî Upload Your Own Sprite</title>
<style>
  :root {
    --bg: #0f172a;        /* slate-900 */
    --panel: #111827;     /* gray-900 */
    --accent: #22d3ee;    /* cyan-400 */
    --text: #e5e7eb;      /* gray-200 */
    --muted: #9ca3af;     /* gray-400 */
    --good: #10b981;      /* emerald-500 */
    --bad:  #ef4444;      /* red-500 */
  }
  html, body { height: 100%; margin: 0; background: radial-gradient(1200px 700px at 70% -10%, #172554, var(--bg)); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"; }
  .wrap { display: grid; grid-template-rows: auto 1fr auto; min-height: 100%; }
  header { padding: 12px 16px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  header h1 { margin: 0; font-size: 18px; letter-spacing: .3px; color: #e2e8f0; }
  header .pill { display: inline-flex; align-items: center; gap: 8px; background: #0b1220; border: 1px solid #1f2937; padding: 8px 10px; border-radius: 12px; }
  header input[type="file"] { display: none; }
  header .btn, .overlay .btn { cursor: pointer; border: 1px solid #1f2937; background: #0b1220; color: var(--text); padding: 8px 12px; border-radius: 10px; font-weight: 600; }
  header .btn:hover, .overlay .btn:hover { border-color: #334155; }
  header input[type="text"] { width: 220px; background: #0b1220; border: 1px solid #1f2937; color: var(--text); padding: 8px 10px; border-radius: 10px; outline: none; }
  main { display: grid; place-items: center; padding: 10px; }
  canvas { width: min(92vw, 520px); height: calc(min(92vw, 520px) * 1.3333); max-height: 86vh; border-radius: 14px; background: linear-gradient(#0ea5e9, #0369a1); box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.05); touch-action: none; }
  .overlay {
    position: fixed; inset: 0; display: grid; place-items: center; pointer-events: none;
  }
  .card {
    pointer-events: auto; background: rgba(2,6,23,.78); backdrop-filter: blur(6px);
    border: 1px solid #1f2937; border-radius: 14px; padding: 16px 18px; width: min(90vw, 520px);
    display: grid; gap: 10px;
  }
  .row { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; }
  .k { color: var(--muted); }
  .v { color: #f1f5f9; font-weight: 700; }
  .hint { color: var(--muted); font-size: 14px; }
  footer { display: flex; justify-content: center; padding: 10px; font-size: 12px; color: #94a3b8; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Flappy <span style="color:var(--accent)">You</span></h1>
    <label class="pill" title="Upload your sprite">
      <input id="fileInput" type="file" accept="image/*" />
      <span>üì∏ Upload Sprite</span>
    </label>
    <div class="pill" style="gap:6px;">
      <input id="urlInput" type="text" placeholder="Paste image URL‚Ä¶" />
      <button id="useUrlBtn" class="btn">Use URL</button>
    </div>
    <button id="startBtn" class="btn">Start</button>
    <span class="pill" style="color:#93c5fd;">‚¨ÜÔ∏è Space / Tap to jump</span>
  </header>

  <main>
    <canvas id="game" width="390" height="520"></canvas>
  </main>

  <footer>No libraries ‚Ä¢ Single file ‚Ä¢ Works offline ‚Ä¢ High score saved locally</footer>
</div>

<div class="overlay" id="overlay" aria-hidden="true"></div>

<script>
(function(){
  // Canvas setup with DPR scaling
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    // Maintain aspect (3:4 ~ 390x520) while honoring CSS size
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  new ResizeObserver(fitCanvas).observe(canvas);
  fitCanvas();

  // UI Elements
  const fileInput = document.getElementById('fileInput');
  const urlInput  = document.getElementById('urlInput');
  const useUrlBtn = document.getElementById('useUrlBtn');
  const startBtn  = document.getElementById('startBtn');
  const overlay   = document.getElementById('overlay');

  // Game constants
  const G = 0.5;          // gravity
  const JUMP = -8.5;      // jump impulse
  const PIPE_GAP = 150;   // vertical opening
  const PIPE_W = 70;      // pipe width
  const SPEED = 2.2;      // horizontal speed
  const SPAWN_MS = 1400;  // pipe spawn interval
  const FLOOR_Y_FRAC = 0.9; // floor level (as fraction of height)

  // State
  let state = 'menu'; // 'menu' | 'running' | 'gameover'
  let player, pipes, score, hi, lastSpawn, lastTime, floorY;
  let spriteImg = null;   // Image object (uploaded / URL)
  let spriteReady = false;
  let spriteScale = 1;    // dynamic scale
  let justPassed = new WeakSet(); // mark pipes scored

  hi = Number(localStorage.getItem('flappy_you_hi') || 0);

  function resetGame() {
    const W = canvas.clientWidth, H = canvas.clientHeight;
    floorY = H * FLOOR_Y_FRAC;

    player = {
      x: W * 0.22,
      y: H * 0.45,
      vy: 0,
      r: Math.max(16, Math.min(26, Math.round(W * 0.04))), // collision radius
      angle: 0
    };
    pipes = [];
    score = 0;
    lastSpawn = performance.now();
    lastTime = performance.now();
  }

  function spawnPipe() {
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const topLimit = 60, bottomLimit = floorY - 60;
    const gapY = Math.floor(Math.random() * (bottomLimit - topLimit - PIPE_GAP)) + topLimit + PIPE_GAP/2;
    const pipe = {
      x: W + PIPE_W,
      gapY,
      w: PIPE_W,
      passed: false,
    };
    pipes.push(pipe);
  }

  function update(dt) {
    const W = canvas.clientWidth, H = canvas.clientHeight;

    // Player physics
    player.vy += G;
    player.y  += player.vy;
    player.angle = Math.atan2(player.vy, SPEED*8); // tilt by velocity

    // Floor/ceiling clamp
    if (player.y - player.r < 0) {
      player.y = player.r;
      player.vy = 0;
    }
    if (player.y + player.r > floorY) {
      player.y = floorY - player.r;
      gameOver();
      return;
    }

    // Pipes
    for (let i = pipes.length - 1; i >= 0; i--) {
      const p = pipes[i];
      p.x -= SPEED;

      // Score when passed center
      if (!p.passed && p.x + p.w < player.x) {
        p.passed = true;
        score++;
        hi = Math.max(hi, score);
        localStorage.setItem('flappy_you_hi', String(hi));
      }

      // Collision (circle vs AABB with gap)
      const topRect = { x: p.x, y: 0, w: p.w, h: p.gapY - PIPE_GAP/2 };
      const botRect = { x: p.x, y: p.gapY + PIPE_GAP/2, w: p.w, h: floorY - (p.gapY + PIPE_GAP/2) };

      if (circleRectIntersect(player.x, player.y, player.r, topRect) ||
          circleRectIntersect(player.x, player.y, player.r, botRect)) {
        gameOver();
        return;
      }

      // Remove offscreen
      if (p.x + p.w < -20) pipes.splice(i, 1);
    }
  }

  function draw() {
    const W = canvas.clientWidth, H = canvas.clientHeight;

    // Sky gradient already via CSS; paint ground
    // Ground
    ctx.fillStyle = '#065f46';
    ctx.fillRect(0, floorY, W, H - floorY);

    // Distant parallax hills
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    for (let i = 0; i < 6; i++) {
      const cx = (i * 140 - (performance.now()/20) % (W+160));
      ctx.beginPath();
      ctx.arc(cx, floorY, 90 + (i%3)*20, Math.PI, 0);
      ctx.fill();
    }

    // Pipes
    for (const p of pipes) {
      // Pipe style
      const gradTop = ctx.createLinearGradient(0,0,0,floorY);
      gradTop.addColorStop(0, '#16a34a');
      gradTop.addColorStop(1, '#065f46');
      ctx.fillStyle = gradTop;

      const topH = p.gapY - PIPE_GAP/2;
      const botY = p.gapY + PIPE_GAP/2;
      const botH = floorY - botY;

      // Top pipe
      ctx.fillRect(p.x, 0, p.w, topH);
      // Lip
      ctx.fillRect(p.x - 4, topH - 14, p.w + 8, 14);

      // Bottom pipe
      ctx.fillRect(p.x, botY, p.w, botH);
      // Lip
      ctx.fillRect(p.x - 4, botY, p.w + 8, 14);
    }

    // Player
    drawPlayer();

    // Score HUD
    ctx.font = 'bold 24px ui-sans-serif, system-ui, -apple-system';
    ctx.textAlign = 'left'; ctx.textBaseline = 'top';
    ctx.fillStyle = 'rgba(255,255,255,.95)';
    ctx.fillText(`Score: ${score}`, 12, 10);
    ctx.fillStyle = 'rgba(255,255,255,.6)';
    ctx.fillText(`Best: ${hi}`, 12, 38);
  }

  function drawPlayer() {
    const W = canvas.clientWidth, H = canvas.clientHeight;

    if (spriteReady && spriteImg && spriteImg.width > 0) {
      // Fit sprite to a visual size ~ 2*radius
      const target = player.r * 2;
      const aspect = spriteImg.width / spriteImg.height;
      let sw = target * 1.15, sh = (target * 1.15) / aspect;
      if (sh > target * 1.6) { // cap tall images
        sh = target * 1.6; sw = sh * aspect;
      }

      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(player.angle * 0.5); // milder tilt looks nicer
      ctx.drawImage(spriteImg, -sw/2, -sh/2, sw, sh);
      ctx.restore();

    } else {
      // Fallback: friendly circle
      const grd = ctx.createRadialGradient(player.x-6, player.y-8, 6, player.x, player.y, player.r+4);
      grd.addColorStop(0, '#fef3c7');
      grd.addColorStop(1, '#f59e0b');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
      ctx.fill();

      // Eye
      ctx.fillStyle = '#111827';
      ctx.beginPath();
      ctx.arc(player.x + 6, player.y - 4, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function circleRectIntersect(cx, cy, r, rect) {
    const rx = rect.x, ry = rect.y, rw = rect.w, rh = rect.h;
    const nearestX = Math.max(rx, Math.min(cx, rx + rw));
    const nearestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - nearestX, dy = cy - nearestY;
    return (dx*dx + dy*dy) <= r*r;
  }

  // Game loop
  function frame(t) {
    if (state === 'running') {
      const dt = Math.min(32, t - lastTime);
      lastTime = t;
      if (t - lastSpawn > SPAWN_MS) { spawnPipe(); lastSpawn = t; }
      update(dt);
      draw();
    } else {
      // Draw idle scene
      draw();
      drawOverlay();
    }
    requestAnimationFrame(frame);
  }

  function drawOverlay() {
    overlay.innerHTML = '';
    overlay.setAttribute('aria-hidden','false');

    const card = document.createElement('div');
    card.className = 'card';

    if (state === 'menu') {
      card.innerHTML = `
        <div class="row"><div class="k">Status</div><div class="v">Ready</div></div>
        <div class="row"><div class="k">Sprite</div><div class="v">${spriteReady ? '‚úÖ Loaded' : 'Default circle'}</div></div>
        <div class="row"><div class="k">How to Play</div><div class="v">Space / Click / Tap to jump</div></div>
        <div class="hint">Upload a face or logo for fun. Then press <b>Start</b>.</div>
        <div class="row"><button class="btn" id="ovStart">Start</button></div>
      `;
      overlay.appendChild(card);
      card.querySelector('#ovStart').onclick = startRun;

    } else if (state === 'gameover') {
      card.innerHTML = `
        <div class="row"><div class="v" style="color:var(--bad)">Game Over</div><div class="v">Score: ${score}</div></div>
        <div class="row"><div class="k">Best</div><div class="v" style="color:var(--good)">${hi}</div></div>
        <div class="hint">Press Space / Tap to try again.</div>
        <div class="row"><button class="btn" id="ovRetry">Restart</button></div>
      `;
      overlay.appendChild(card);
      card.querySelector('#ovRetry').onclick = startRun;
    }
  }

  function startRun() {
    resetGame();
    state = 'running';
    overlay.setAttribute('aria-hidden','true');
    lastTime = performance.now();
    lastSpawn = performance.now() + 500; // slight delay
  }

  function gameOver() {
    state = 'gameover';
    draw();
    drawOverlay();
  }

  // Controls
  function jump() {
    if (state === 'menu') startRun();
    else if (state === 'gameover') startRun();
    else {
      player.vy = JUMP;
    }
  }
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.key === ' ') { e.preventDefault(); jump(); }
  }, { passive:false });
  canvas.addEventListener('pointerdown', (e) => { e.preventDefault(); jump(); }, { passive:false });

  startBtn.addEventListener('click', startRun);

  // Sprite loaders
  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    await loadSprite(url, true);
  });

  useUrlBtn.addEventListener('click', async () => {
    const url = (urlInput.value || '').trim();
    if (!url) return;
    await loadSprite(url, false);
  });

  async function loadSprite(url, revokeLater) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        spriteImg = img;
        spriteReady = true;
        if (revokeLater) {
          // revoke after next frame to ensure texture upload done
          requestAnimationFrame(() => URL.revokeObjectURL(url));
        }
        // If in menu, update overlay to show "Loaded"
        if (state !== 'running') drawOverlay();
        resolve();
      };
      img.onerror = (err) => {
        spriteImg = null; spriteReady = false;
        alert('Could not load that image. Try a different file/URL.');
        if (state !== 'running') drawOverlay();
        reject(err);
      };
      img.src = url;
    });
  }

  // Kick things off
  resetGame();
  draw();
  drawOverlay();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
